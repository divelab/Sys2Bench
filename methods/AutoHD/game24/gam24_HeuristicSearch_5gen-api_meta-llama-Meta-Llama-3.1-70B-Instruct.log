Generation 0: 
Function: 
# Heuristic Description: Calculate the difference between the maximum number in the current state and the goal, considering the potential operations that can be applied to the numbers.

def calc_heuristic(numbers):
    max_num = max(numbers)
    max_num_plus = max_num + sum(numbers) - max_num
    max_num_minus = max_num - sum(abs(num) for num in numbers if num!= max_num)
    max_num_mul = max_num * max(numbers)
    max_num_div = max_num / min(abs(num) for num in numbers if num!= 0 and num!= max_num)
    
    max_val = max(max_num, max_num_plus, max_num_minus, max_num_mul, max_num_div)
    heuristic_val = abs(24 - max_val)
    
    return heuristic_val
Accuracy: 0.0 
Function: 
# Heuristic Description: Calculate the difference between the goal and the closest number that can be obtained by combining the given numbers using basic arithmetic operations.

def calc_heuristic(numbers):
    def combine(nums):
        if len(nums) == 1:
            return nums[0]
        min_diff = float('inf')
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                a, b = nums[i], nums[j]
                remaining = nums[:i] + nums[i+1:j] + nums[j+1:]
                for op in [lambda x, y: x+y, lambda x, y: x-y, lambda x, y: y-x, lambda x, y: x*y, lambda x, y: x/y, lambda x, y: y/x]:
                    try:
                        combined = op(a, b)
                        diff = abs(24 - combined)
                        if diff < min_diff:
                            min_diff = diff
                        new_nums = remaining + [combined]
                        diff = abs(24 - combine(new_nums))
                        if diff < min_diff:
                            min_diff = diff
                    except ZeroDivisionError:
                        pass
        return min_diff

    return combine(numbers)
Accuracy: 0.0 
Function: 
# Heuristic Description: Calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def closest_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        min_diff = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_diff = closest_to_24([val] + remaining)
                        min_diff = min(min_diff, new_diff)
        return min_diff

    return closest_to_24(numbers)
Accuracy: 0.625 
Function: 
# Heuristic Description: Calculate the difference between the goal and the closest number that can be obtained by combining the given numbers using basic arithmetic operations.

def calc_heuristic(numbers):
    # Base case: if the goal is already achieved, return 0
    if len(numbers) == 1 and numbers[0] == 24:
        return 0
    
    # Initialize the minimum difference
    min_diff = float('inf')
    
    # Generate all possible combinations of numbers
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            a, b = numbers[i], numbers[j]
            
            # Calculate the result of each possible operation
            results = [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]
            
            # Calculate the difference between the goal and the result
            for result in results:
                diff = abs(24 - result)
                min_diff = min(min_diff, diff)
    
    # Return the minimum difference
    return min_diff
Accuracy: 0.5 
Function: 
# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the minimum difference
    min_diff = min(diff)
    
    # If the minimum difference is 0, return 0
    if min_diff == 0:
        return 0
    
    # Otherwise, return the minimum difference
    return min_diff
Accuracy: 0.125 
Generation 1: 
Function: 
# Common Idea: The provided heuristics calculate the difference between the current numbers and the goal, either directly or by considering the minimum number of operations required to reach the goal.

# Heuristic Description: This heuristic calculates the maximum number of factors of the goal that can be obtained by combining the current numbers using basic arithmetic operations.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def count_factors(numbers):
        if len(numbers) == 1:
            count = 0
            for i in range(1, 25):
                if 24 % i == 0 and i % numbers[0] == 0:
                    count += 1
            return count
        max_count = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_count = count_factors([val] + remaining)
                        max_count = max(max_count, new_count)
        return max_count

    return 24 - count_factors(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics focus on calculating the difference or minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the product of the differences between the current numbers and the goal, considering the average of the numbers.

def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    avg_num = sum(Numbers) / len(Numbers)
    prod_diff = 1
    for num in Numbers:
        prod_diff *= abs(num - avg_num)
    return prod_diff
Accuracy: 0.0 
Function: 
# Common Idea: The existing heuristics focus on calculating the difference between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the harmonic mean of the current numbers and the goal, with the goal of reaching a harmonic mean of 24.

def calc_heuristic(Numbers):
    # Calculate the harmonic mean of the current numbers
    harmonic_mean = len(Numbers) / sum(1/num for num in Numbers)
    
    # Calculate the heuristic value as the difference between the harmonic mean and the goal
    heuristic_val = abs(harmonic_mean - 24)
    
    # If the goal is achieved, return 0
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    # Otherwise, return the heuristic value
    return heuristic_val
Accuracy: 0.0 
Function: 
# Common Idea: Calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

# Heuristic Description: Calculate the average difference between the goal and the closest numbers that can be obtained by combining the current numbers using basic arithmetic operations.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def average_diff_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        total_diff = 0
        count = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        total_diff += average_diff_to_24([val] + remaining)
                        count += 1
        return total_diff / count if count > 0 else float('inf')

    return average_diff_to_24(numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the difference or minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: Calculate the harmonic mean of the current numbers to evaluate how close they are to the goal.

def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    harmonic_mean = len(Numbers) / sum(1/x for x in Numbers)
    heuristic_val = abs(harmonic_mean - 24)
    return heuristic_val
Accuracy: 0.0 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average of the absolute differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the absolute differences between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The existing heuristics calculate the difference between the current numbers and the goal, or the minimum number of operations required to reach the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal by considering the combinations of the current numbers and their distances to the goal.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def closest_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        min_diff = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_diff = closest_to_24([val] + remaining)
                        min_diff = min(min_diff, new_diff)
        return min_diff

    def num_operations(numbers):
        if len(numbers) == 1:
            return 0
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_ops = num_operations([val] + remaining) + 1
                        min_ops = min(min_ops, new_ops)
        return min_ops

    if 24 in Numbers:
        return 0
    else:
        return num_operations(Numbers) * closest_to_24(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The existing heuristics are based on calculating the difference between the current numbers and the goal, either directly or by combining the numbers using basic arithmetic operations.

# Heuristic Description: Calculate the minimum number of operations required to reach the goal by considering the geometric mean of the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    import math
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the geometric mean of the differences
    geo_mean_diff = math.exp(math.fsum(math.log(x) for x in diff) / len(diff))
    
    # If the geometric mean difference is 0, return 0
    if geo_mean_diff == 0:
        return 0
    
    # Otherwise, return the geometric mean difference
    return geo_mean_diff
Accuracy: 0.125 
Function: 
# Common Idea: The heuristics calculate the difference or minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: Calculate the average distance of the current numbers from the goal and adjust it based on the number of operations required to reach the goal.

def calc_heuristic(Numbers):
    # Calculate the average distance of the current numbers from the goal
    avg_diff = sum(abs(num - 24) for num in Numbers) / len(Numbers)
    
    # Calculate the number of operations required to reach the goal
    num_ops = len(Numbers) - 1
    
    # Adjust the average distance based on the number of operations
    heuristic_val = avg_diff * (1 + num_ops / 10)
    
    # If the goal is achieved, return 0
    if 24 in Numbers and len(Numbers) == 1:
        return 0
    
    # Otherwise, return the adjusted average distance
    return heuristic_val
Accuracy: 0.125 
Function: 
# Common Idea: The existing heuristics calculate the difference or minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum number of operations that can be performed with the current numbers without exceeding the goal.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def max_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        max_ops = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0 and val <= 24:
                        new_ops = 1 + max_operations([val] + remaining)
                        max_ops = max(max_ops, new_ops)
        return max_ops

    return max_operations(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The heuristics calculate the minimum distance or difference between the current state and the goal state.

# Heuristic Description: This heuristic calculates the maximum number of operations required to reach the goal by considering the maximum difference between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: All the provided heuristics calculate a difference or a minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the sum of the differences between each pair of numbers and the goal, and then returns the minimum sum.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def min_sum_diff(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        min_diff = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_diff = min_sum_diff([val] + remaining)
                        min_diff = min(min_diff, new_diff + abs(numbers[i] - 24) + abs(numbers[j] - 24))
        return min_diff

    return min_sum_diff(Numbers)
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the difference between the current numbers and the goal, and return the minimum difference as the heuristic value.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the absolute differences and the number of operations required to reach the goal.

def calc_heuristic(Numbers):
    # Calculate the absolute differences between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average of the differences between the current numbers and the goal, giving more weight to smaller differences.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average of the differences
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the difference or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the product of the differences between the current numbers and the goal, considering the properties of the arithmetic operations.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def product_diff(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        min_diff = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_diff = product_diff([val] + remaining)
                        min_diff = min(min_diff, new_diff)
        return min_diff

    return product_diff(Numbers)
Accuracy: 0.625 
Function: 
# Common Idea: Calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

# Heuristic Description: Calculate the average difference between the goal and the closest number that can be obtained by combining each pair of current numbers using basic arithmetic operations.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def avg_diff_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        total_diff = 0
        count = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        total_diff += abs(val - 24)
                        count += 1
        return total_diff / count if count > 0 else float('inf')

    return avg_diff_to_24(numbers)
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

# Heuristic Description: Calculate the minimum number of operations required to reach the goal, considering any operation using (+, -, *, /) with the current state.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def min_operations_to_24(numbers):
        if len(numbers) == 1 and numbers[0] == 24:
            return 0
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_ops = 1 + min_operations_to_24([val] + remaining)
                        min_ops = min(min_ops, new_ops)
        return min_ops

    return min_operations_to_24(numbers)
Accuracy: 0.875 
Function: 
# Common Idea: Calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

# Heuristic Description: Calculate the sum of the differences between each number in the current state and the goal, prioritizing numbers that are closer to the goal.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def closest_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        min_diff = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_diff = closest_to_24([val] + remaining)
                        min_diff = min(min_diff, new_diff)
        return min_diff

    def sum_of_diffs(numbers):
        return sum(abs(num - 24) for num in numbers)

    return sum_of_diffs(numbers)
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference or distance between the current state and the goal state using various mathematical operations.

# Heuristic Description: Calculate the average difference between the goal and each number in the current state, considering all possible combinations of numbers and operations.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def avg_diff_to_24(numbers):
        if len(numbers) == 1:
            return abs(numbers[0] - 24)
        sum_diff = 0
        count = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        sum_diff += abs(val - 24)
                        count += 1
                        sum_diff += avg_diff_to_24([val] + remaining) * len([val] + remaining)
                        count += len([val] + remaining)
        return sum_diff / count if count > 0 else float('inf')

    return avg_diff_to_24(numbers)
Accuracy: 0.0 
Generation 2: 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, and then calculates the sum of the differences between each pair of numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # Calculate the sum of the differences between each pair of numbers and the goal
    sum_diff = sum([abs(num1 - num2) for i, num1 in enumerate(Numbers) for j, num2 in enumerate(Numbers) if i < j])
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the product of the maximum difference and the sum of the differences
    return max_diff * sum_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum possible value that can be obtained by combining the current numbers using the allowed operations.

def calc_heuristic(Numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def max_value(numbers):
        if len(numbers) == 1:
            return numbers[0]
        max_val = float('-inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_val = max_value([val] + remaining)
                        max_val = max(max_val, new_val)
        return max_val

    max_val = max_value(Numbers)
    if max_val == 24:
        return 0
    else:
        return 24 - max_val
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the harmonic mean of the differences between the current numbers and the goal, considering the properties of the arithmetic operations.

def calc_heuristic(Numbers):
    diff = [abs(num - 24) for num in Numbers]
    if 0 in diff:
        return 0
    else:
        return len(diff) / sum(1/x for x in diff)
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the sum of the differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the sum of the differences
    sum_diff = sum(diff)
    
    # If the sum of the differences is 0, return 0
    if sum_diff == 0:
        return 0
    
    # Otherwise, return the sum of the differences
    return sum_diff
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the minimum difference between any two numbers in the current state and the goal, considering the differences between any two numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between any two numbers in the current state and the goal
    diff = [abs(num1 - num2) for i, num1 in enumerate(Numbers) for num2 in Numbers[i+1:]]
    
    # Add the differences between each number and the goal
    diff += [abs(num - 24) for num in Numbers]
    
    # Calculate the minimum difference
    min_diff = min(diff)
    
    # If the minimum difference is 0, return 0
    if min_diff == 0:
        return 0
    
    # Otherwise, return the minimum difference
    return min_diff
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal from the current state.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            if numbers[0] == 24:
                return 0
            else:
                return float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for op in ['+', '-', '*', '/']:
                    if op == '+':
                        new_num = numbers[i] + numbers[j]
                    elif op == '-':
                        new_num = numbers[i] - numbers[j]
                    elif op == '*':
                        new_num = numbers[i] * numbers[j]
                    elif op == '/':
                        if numbers[j] == 0:
                            continue
                        new_num = numbers[i] / numbers[j]
                    new_ops = min_operations([new_num] + remaining)
                    if new_ops!= float('inf'):
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.625 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal by using a combination of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or difference between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal.

def calc_heuristic(Numbers):
    def is_close_enough(num):
        return abs(num - 24) < 1e-6

    def get_min_ops(numbers):
        if len(numbers) == 1:
            if is_close_enough(numbers[0]):
                return 0
            else:
                return float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for op in ['+', '-', '*', '/']:
                    if op == '+':
                        val = numbers[i] + numbers[j]
                    elif op == '-':
                        val = numbers[i] - numbers[j]
                    elif op == '*':
                        val = numbers[i] * numbers[j]
                    else:
                        if numbers[j]!= 0:
                            val = numbers[i] / numbers[j]
                        else:
                            continue
                    new_ops = get_min_ops([val] + remaining)
                    if new_ops!= float('inf'):
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return get_min_ops(Numbers)
Accuracy: 0.625 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            if numbers[0] == 24:
                return 0
            else:
                return float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the maximum difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum difference
    max_diff = max(diff)
    
    # If the maximum difference is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum difference
    return max_diff
Accuracy: 0.25 
Generation 3: 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the variance of the current numbers as a measure of how spread out they are from the goal.

def calc_heuristic(Numbers):
    import numpy as np
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    else:
        return np.var(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of bits required to represent the current numbers in binary, considering the bits required to represent the goal.

def calc_heuristic(Numbers):
    def count_bits(num):
        return len(bin(num)[2:])

    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    else:
        return sum(count_bits(num) for num in Numbers) - count_bits(24)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average of the differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average of the reciprocal of the absolute differences between each pair of numbers and 24, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    total_diff = 0
    for num in Numbers:
        total_diff += 1 / abs(num - 24) if num!= 24 else float('inf')
    return 1 / (len(Numbers) * total_diff)
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the sum of the absolute differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the sum of the differences
    sum_diff = sum(diff)
    
    # If the sum of the differences is 0, return 0
    if sum_diff == 0:
        return 0
    
    # Otherwise, return the sum of the differences
    return sum_diff
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the absolute difference between the goal and the maximum value that can be obtained by combining the current numbers using addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def max_value(numbers):
        if len(numbers) == 1:
            return numbers[0]
        max_val = float('-inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('-inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('-inf')]:
                    if val > 0:
                        new_val = max_value([val] + remaining)
                        max_val = max(max_val, new_val)
        return max_val

    return abs(24 - max_value(Numbers))
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the standard deviation of the current numbers, assuming that the numbers are closer to the goal when they have smaller standard deviation.

def calc_heuristic(Numbers):
    import math
    # Calculate the mean of the current numbers
    mean = sum(Numbers) / len(Numbers)
    
    # Calculate the variance of the current numbers
    variance = sum((x - mean) ** 2 for x in Numbers) / len(Numbers)
    
    # Calculate the standard deviation of the current numbers
    std_dev = math.sqrt(variance)
    
    # If the goal is achieved, return 0
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    # Otherwise, return the standard deviation
    return std_dev
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum value that can be achieved by combining any two numbers in the current state, and then calculates the difference between this maximum value and the goal.

def calc_heuristic(Numbers):
    if len(Numbers) == 1:
        return 0 if Numbers[0] == 24 else abs(Numbers[0] - 24)
    
    max_val = float('-inf')
    for i in range(len(Numbers)):
        for j in range(i + 1, len(Numbers)):
            for val in [Numbers[i] + Numbers[j], Numbers[i] - Numbers[j], Numbers[j] - Numbers[i], Numbers[i] * Numbers[j], Numbers[i] / Numbers[j] if Numbers[j]!= 0 else float('-inf'), Numbers[j] / Numbers[i] if Numbers[i]!= 0 else float('-inf')]:
                if val > 0:
                    max_val = max(max_val, val)
    
    return abs(max_val - 24)
Accuracy: 0.125 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the sum of the differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the sum of the differences
    sum_diff = sum(diff)
    
    # If the sum of the differences is 0, return 0
    if sum_diff == 0:
        return 0
    
    # Otherwise, return the sum of the differences
    return sum_diff
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the standard deviation of the current numbers as a measure of how spread out they are from the goal.

def calc_heuristic(Numbers):
    import math
    if len(Numbers) == 1:
        return 0 if Numbers[0] == 24 else float('inf')
    mean = sum(Numbers) / len(Numbers)
    variance = sum((x - mean) ** 2 for x in Numbers) / len(Numbers)
    std_dev = math.sqrt(variance)
    return std_dev
Accuracy: 0.375 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the sum of the differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the sum of the differences
    sum_diff = sum(diff)
    
    # If the sum of the differences is 0, return 0
    if sum_diff == 0:
        return 0
    
    # Otherwise, return the sum of the differences
    return sum_diff
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal, and the minimum number of operations required to reach the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # Calculate the minimum number of operations required to reach the goal
    min_ops = float('inf')
    for i in range(len(Numbers)):
        for j in range(i + 1, len(Numbers)):
            remaining = Numbers[:i] + Numbers[i + 1:j] + Numbers[j + 1:]
            for val in [Numbers[i] + Numbers[j], Numbers[i] - Numbers[j], Numbers[j] - Numbers[i], Numbers[i] * Numbers[j], Numbers[i] / Numbers[j] if Numbers[j]!= 0 else float('inf'), Numbers[j] / Numbers[i] if Numbers[i]!= 0 else float('inf')]:
                if val > 0:
                    new_ops = len(Numbers) - len(remaining) - 1
                    min_ops = min(min_ops, new_ops)
    
    # Return the average difference multiplied by the minimum number of operations
    if avg_diff == 0:
        return 0
    else:
        return avg_diff * min_ops
Accuracy: 0.25 
Function: 
# Common Idea: Calculate the difference between the current numbers and the goal to estimate the distance to the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the average difference
    avg_diff = sum(diff) / len(diff)
    
    # If the average difference is 0, return 0
    if avg_diff == 0:
        return 0
    
    # Otherwise, return the average difference
    return avg_diff
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the absolute difference between the closest number to 24 in the current state and 24, and uses the number of operations required to reach the goal as a secondary tiebreaker.

def calc_heuristic(Numbers):
    def closest_to_goal(numbers):
        closest = min(abs(num - 24) for num in numbers)
        return closest

    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    heuristic_val = closest_to_goal(Numbers)
    if heuristic_val!= 0:
        heuristic_val += min_operations(Numbers)
    return heuristic_val
Accuracy: 0.625 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the sum of the logarithmic differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    import math
    # Calculate the logarithmic differences between the current numbers and the goal
    log_diff = [math.log(abs(num - 24) + 1) for num in Numbers]
    
    # Calculate the sum of the logarithmic differences
    sum_log_diff = sum(log_diff)
    
    # If the sum of the logarithmic differences is 0, return 0
    if sum_log_diff == 0:
        return 0
    
    # Otherwise, return the sum of the logarithmic differences
    return sum_log_diff
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum absolute difference between the current numbers and the goal, considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def max_diff(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else abs(numbers[0] - 24)
        max_diff_val = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_diff = max_diff([val] + remaining)
                        max_diff_val = max(max_diff_val, new_diff, abs(val - 24))
        return max_diff_val

    return max_diff(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the sum of the differences between each pair of numbers and the goal, considering the absolute difference and the difference in the number of operations required to reach the goal.

def calc_heuristic(Numbers):
    def sum_of_differences(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        sum_diff = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        sum_diff += abs(val - 24) + abs(len(numbers) - len([val] + remaining))
        return sum_diff

    return sum_of_differences(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the average difference between the current numbers and the goal, considering the differences between the current numbers and the goal, and the number of operations required to reach the goal.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    diff = [abs(num - 24) for num in Numbers]
    avg_diff = sum(diff) / len(diff)
    min_ops = min_operations(Numbers)
    heuristic_val = avg_diff + min_ops / len(Numbers)

    return 0 if heuristic_val == 0 else heuristic_val
Accuracy: 0.75 
Generation 4: 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal, considering the priority of operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1 and numbers[0] == 24:
            return 0
        operations = 0
        while len(numbers) > 1:
            min_diff = float('inf')
            min_pair = None
            for i in range(len(numbers)):
                for j in range(i + 1, len(numbers)):
                    for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                        if val > 0 and abs(val - 24) < min_diff:
                            min_diff = abs(val - 24)
                            min_pair = (i, j)
            numbers.remove(numbers[min_pair[0]])
            numbers.remove(numbers[min_pair[0]])
            numbers.append(min_diff)
            operations += 1
        return operations + abs(numbers[0] - 24)

    return min_operations(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the sum of the absolute differences between the current numbers and the goal, considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def sum_diff(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else abs(numbers[0] - 24)
        sum_diff_val = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_diff = sum_diff([val] + remaining)
                        sum_diff_val += new_diff + abs(val - 24)
        return sum_diff_val

    return sum_diff(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the sum of the absolute differences between the current numbers and the goal, considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def sum_diff(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else abs(numbers[0] - 24)
        sum_diff_val = 0
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_diff = sum_diff([val] + remaining)
                        sum_diff_val += new_diff + abs(val - 24)
        return sum_diff_val

    return sum_diff(Numbers)
Accuracy: 0.0 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum of the absolute differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    import math
    # Calculate the absolute differences between the current numbers and the goal
    abs_diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum of the absolute differences
    max_abs_diff = max(abs_diff)
    
    # If the maximum of the absolute differences is 0, return 0
    if max_abs_diff == 0:
        return 0
    
    # Otherwise, return the maximum of the absolute differences
    return max_abs_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the product of the differences between the current numbers and the goal, considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the difference between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the product of the differences
    prod_diff = 1
    for num in diff:
        prod_diff *= num
    
    # If the product of the differences is 0, return 0
    if prod_diff == 0:
        return 0
    
    # Otherwise, return the product of the differences
    return prod_diff
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum sum of absolute differences between the current numbers and the goal, considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_diff(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else abs(numbers[0] - 24)
        min_diff_val = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_diff = min_diff([val] + remaining)
                        min_diff_val = min(min_diff_val, new_diff + abs(val - 24))
        return min_diff_val

    return min_diff(Numbers)
Accuracy: 0.5 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the product of the differences between the current numbers and the goal, with a penalty for division operations.

def calc_heuristic(Numbers):
    import math
    # Calculate the differences between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the product of the differences
    prod_diff = 1
    for d in diff:
        prod_diff *= (d + 1)
    
    # If the product of the differences is 1, return 0
    if prod_diff == 1:
        return 0
    
    # Otherwise, return the product of the differences
    return prod_diff
Accuracy: 0.125 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum of the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the differences between the current numbers and the goal
    diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum of the differences
    max_diff = max(diff)
    
    # If the maximum of the differences is 0, return 0
    if max_diff == 0:
        return 0
    
    # Otherwise, return the maximum of the differences
    return max_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum of the absolute differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the absolute differences between the current numbers and the goal
    abs_diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum of the absolute differences
    max_abs_diff = max(abs_diff)
    
    # If the maximum of the absolute differences is 0, return 0
    if max_abs_diff == 0:
        return 0
    
    # Otherwise, return the maximum of the absolute differences
    return max_abs_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal, considering the optimal combination of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else 1
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal by iteratively applying the closest operation to the goal.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to reach the goal by considering the differences between the current numbers and the goal.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = 1 + min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal by considering all possible combinations of operations and their corresponding distances.

def calc_heuristic(Numbers):
    import math
    import itertools
    import operator

    ops = {
        '+': operator.add,
        '-': operator.sub,
        '*': operator.mul,
        '/': operator.truediv
    }

    def min_ops(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops_val = float('inf')
        for op in ops:
            for i in range(len(numbers)):
                for j in range(i + 1, len(numbers)):
                    remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                    if op == '/' and (numbers[i] == 0 or numbers[j] == 0):
                        continue
                    try:
                        val = ops[op](numbers[i], numbers[j])
                        new_ops = min_ops([val] + remaining)
                        min_ops_val = min(min_ops_val, new_ops + 1)
                    except ZeroDivisionError:
                        pass
        return min_ops_val

    return min_ops(Numbers)
Accuracy: 0.625 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal by considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the maximum absolute difference between the current numbers and the goal.

def calc_heuristic(Numbers):
    # Calculate the absolute differences between the current numbers and the goal
    abs_diff = [abs(num - 24) for num in Numbers]
    
    # Calculate the maximum absolute difference
    max_abs_diff = max(abs_diff)
    
    # If the maximum absolute difference is 0, return 0
    if max_abs_diff == 0:
        return 0
    
    # Otherwise, return the maximum absolute difference
    return max_abs_diff
Accuracy: 0.25 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal by considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_ops(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops_val = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_ops([val] + remaining)
                        min_ops_val = min(min_ops_val, new_ops + 1)
        return min_ops_val

    return min_ops(Numbers)
Accuracy: 0.875 
Function: 
# Common Idea: The provided heuristics calculate the distance between the current state and the goal by considering the differences between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum absolute difference between the current numbers and the goal, considering all possible combinations of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_diff(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else abs(numbers[0] - 24)
        min_diff_val = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_diff = min_diff([val] + remaining)
                        min_diff_val = min(min_diff_val, new_diff, abs(val - 24))
        return min_diff_val

    return min_diff(Numbers)
Accuracy: 0.5 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal by recursively exploring all possible operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else float('inf')
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.875 
Test the best heuristic in the last generation: 
Function: 
# Common Idea: The provided heuristics calculate the distance or minimum number of operations between the current numbers and the goal.

# Heuristic Description: This heuristic calculates the minimum number of operations required to transform the current numbers into the goal, considering the optimal combination of addition, subtraction, multiplication, and division operations.

def calc_heuristic(Numbers):
    def min_operations(numbers):
        if len(numbers) == 1:
            return 0 if numbers[0] == 24 else 1
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in [numbers[i] + numbers[j], numbers[i] - numbers[j], numbers[j] - numbers[i], numbers[i] * numbers[j], numbers[i] / numbers[j] if numbers[j]!= 0 else float('inf'), numbers[j] / numbers[i] if numbers[i]!= 0 else float('inf')]:
                    if val > 0:
                        new_ops = min_operations([val] + remaining)
                        min_ops = min(min_ops, new_ops + 1)
        return min_ops

    return min_operations(Numbers)
Accuracy: 0.71 
Test the best heuristic in all the generations: 
Function: 
# Common Idea: The provided heuristics calculate the difference between the goal and the closest number that can be obtained by combining the current numbers using basic arithmetic operations.

# Heuristic Description: Calculate the minimum number of operations required to reach the goal, considering any operation using (+, -, *, /) with the current state.

def calc_heuristic(numbers):
    def combine(a, b):
        return [a + b, a - b, b - a, a * b, a / b if b!= 0 else float('inf'), b / a if a!= 0 else float('inf')]

    def min_operations_to_24(numbers):
        if len(numbers) == 1 and numbers[0] == 24:
            return 0
        min_ops = float('inf')
        for i in range(len(numbers)):
            for j in range(i + 1, len(numbers)):
                remaining = numbers[:i] + numbers[i + 1:j] + numbers[j + 1:]
                for val in combine(numbers[i], numbers[j]):
                    if val > 0:
                        new_ops = 1 + min_operations_to_24([val] + remaining)
                        min_ops = min(min_ops, new_ops)
        return min_ops

    return min_operations_to_24(numbers)
Accuracy: 0.69 
