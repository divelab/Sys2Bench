Generation 0: 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    heuristic_val = float('inf')

    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(nums)-1):
            expression = str(nums[0])
            for i in range(len(ops)):
                expression += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expression)
                heuristic_val = min(heuristic_val, abs(target - result))
            except ZeroDivisionError:
                continue
                
    return heuristic_val
Accuracy: 0.625 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    target = 24
    if len(Numbers) == 1 and Numbers[0] == target:
        return 0
    
    best_diff = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product('+-*/', repeat=len(nums)-1):
            expression = str(nums[0])
            for i in range(len(ops)):
                expression += ops[i] + str(nums[i + 1])
            try:
                result = eval(expression)
                best_diff = min(best_diff, abs(target - result))
            except ZeroDivisionError:
                continue
    
    return best_diff
Accuracy: 0.625 
Function: 
def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    possible_values = set(Numbers)
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                a, b = Numbers[i], Numbers[j]
                possible_values.add(a + b)
                possible_values.add(a - b)
                possible_values.add(b - a)
                possible_values.add(a * b)
                if b != 0:
                    possible_values.add(a / b)
                if a != 0:
                    possible_values.add(b / a)

    heuristic_val = min(abs(value - 24) for value in possible_values)
    return heuristic_val
Accuracy: 0.625 
Function: 
def calc_heuristic(Numbers):
    from itertools import permutations, product

    if len(Numbers) == 1:
        return abs(Numbers[0] - 24)

    operations = ['+', '-', '*', '/']
    heuristic_val = float('inf')

    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(nums)-1):
            expression = str(nums[0])
            for i in range(len(ops)):
                expression += f" {ops[i]} {nums[i+1]}"
            try:
                result = eval(expression)
                heuristic_val = min(heuristic_val, abs(result - 24))
            except ZeroDivisionError:
                continue

    return heuristic_val
Accuracy: 0.75 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                heuristic_val = min(heuristic_val, abs(target - result))
            except ZeroDivisionError:
                continue
    
    return heuristic_val
Accuracy: 0.75 
Generation 1: 
Function: 
def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    target = 24
    ratios = [num / target for num in Numbers if num != 0]
    heuristic_val = float('inf')
    
    if ratios:
        product_of_ratios = 1
        for ratio in ratios:
            product_of_ratios *= ratio
        heuristic_val = abs(product_of_ratios - 1) * target

    return heuristic_val
Accuracy: 0.0 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    max_value = max(Numbers)
    min_value = min(Numbers)
    
    for num in Numbers:
        max_value = max(max_value, num * max_value)
        if min_value != 0:
            min_value = min(min_value, max_value / num)

    heuristic_val = abs(max(24, min_value) - 24) + abs(max_value - 24)
    return heuristic_val
Accuracy: 0.125 
Function: 
from itertools import combinations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    operations_needed = 0
    target = 24
    
    while len(Numbers) > 1:
        best_combination = None
        best_result = float('inf')

        for combo in combinations(Numbers, 2):
            a, b = combo
            possible_results = [
                a + b, a - b, b - a, a * b
            ]
            if b != 0:
                possible_results.append(a / b)
            if a != 0:
                possible_results.append(b / a)
            
            for result in possible_results:
                if abs(result - target) < abs(best_result - target):
                    best_result = result
                    best_combination = combo

        if best_combination:
            Numbers.remove(best_combination[0])
            Numbers.remove(best_combination[1])
            Numbers.append(best_result)
            operations_needed += 1

    heuristic_val = abs(Numbers[0] - target) + operations_needed
    return heuristic_val
Accuracy: 0.0 
Function: 
def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    max_product = 1
    min_number = min(Numbers)
    
    for number in Numbers:
        max_product *= number

    heuristic_val = abs(max_product / min_number - 24)
    return heuristic_val
Accuracy: 0.125 
Function: 
from itertools import combinations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')

    for combo in combinations(Numbers, 2):
        a, b = combo
        if a != 0:
            heuristic_val = min(heuristic_val, abs((a / b) - target))
        if b != 0:
            heuristic_val = min(heuristic_val, abs((b / a) - target))
        heuristic_val = min(heuristic_val, abs((a * b) - target))
    
    return heuristic_val if heuristic_val != float('inf') else -1
Accuracy: 0.25 
Function: 
from itertools import combinations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = 0
    
    while len(Numbers) > 1:
        max_result = float('-inf')
        
        for num1, num2 in combinations(Numbers, 2):
            possible_results = [
                num1 + num2,
                num1 - num2,
                num2 - num1,
                num1 * num2,
                num1 / num2 if num2 != 0 else float('inf'),
                num2 / num1 if num1 != 0 else float('inf')
            ]
            max_result = max(max_result, *possible_results)
        
        Numbers.remove(max(num1, num2))
        Numbers.remove(min(num1, num2))
        Numbers.append(max_result)
        heuristic_val += 1
    
    return heuristic_val + abs(target - Numbers[0])
Accuracy: 0.0 
Function: 
def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    heuristic_val = 0
    
    for number in Numbers:
        if number > target:
            heuristic_val += (number - target) ** 2
        else:
            heuristic_val += (target - number) ** 2

    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if len(Numbers) == 1 and Numbers[0] == 24:
        return 0
    
    total_product = 1
    for num in Numbers:
        total_product *= num
    
    heuristic_val = abs(total_product - 24) / 24
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    max_value = float('-inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                max_value = max(max_value, result)
            except ZeroDivisionError:
                continue
    
    heuristic_val = max(0, abs(target - max_value))
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    max_value = float('-inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                max_value = max(max_value, result)
            except ZeroDivisionError:
                continue
    
    heuristic_val = abs(target - max_value)
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, combinations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                # Calculate addition and multiplication
                addition = nums[i] + nums[j]
                multiplication = nums[i] * nums[j]
                
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Add results back to the list
                new_nums.append(addition)
                heuristic_val = min(heuristic_val, abs(target - addition))
                
                new_nums[-1] = multiplication
                heuristic_val = min(heuristic_val, abs(target - multiplication))
    
    return heuristic_val
Accuracy: 0.5 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    product = 1
    for num in Numbers:
        product *= num
    
    heuristic_val = abs(product - 24)
    
    return heuristic_val
Accuracy: 0.25 
Function: 
from functools import reduce
import operator

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product_val = reduce(operator.mul, Numbers, 1)
    heuristic_val = abs(target - product_val) + (len(Numbers) - 1) * 2  # Adjusting for number of operations needed
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average) * len(Numbers)
    
    return heuristic_val
Accuracy: 0.125 
Generation 2: 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average = sum(Numbers) / len(Numbers)
    
    # Heuristic value based on the average distance to the target
    heuristic_val = abs(target - average) * len(Numbers)
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average_value = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average_value)

    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average) * len(Numbers)
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    current_sum = sum(Numbers)
    
    # Calculate the difference from the target
    heuristic_val = abs(target - current_sum)
    
    # Estimate the number of operations needed
    operations_needed = heuristic_val // 6  # Assuming max single operation can change the total by 6 (for example 3+3 or 6-0)
    
    return heuristic_val + operations_needed
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average)
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    summation = 0
    
    for num in Numbers:
        product *= num
        summation += num
    
    heuristic_val = min(abs(target - product), abs(target - summation))
    return heuristic_val
Accuracy: 0.375 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    sum_values = sum(Numbers)
    
    if sum_values == 0:
        return float('inf')
    
    heuristic_val = abs(target - sum_values) / target
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, combinations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')

    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                # Calculate results for addition, subtraction, multiplication, and division
                results = [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[j] - nums[i],
                    nums[i] * nums[j]
                ]
                if nums[j] != 0:
                    results.append(nums[i] / nums[j])
                if nums[i] != 0:
                    results.append(nums[j] / nums[i])
                
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                for result in results:
                    new_nums.append(result)
                    heuristic_val = min(heuristic_val, abs(target - result))
                    new_nums.pop()  # remove the last added number for the next iteration
                
    return heuristic_val
Accuracy: 0.625 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    total_sum = 0
    count = 0
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                total_sum += result
                count += 1
            except ZeroDivisionError:
                continue
    
    average_value = total_sum / count if count > 0 else 0
    heuristic_val = abs(target - average_value)
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, combinations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Calculate addition, subtraction, multiplication, and division
                operations = [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[j] - nums[i],
                    nums[i] * nums[j]
                ]
                
                if nums[j] != 0:
                    operations.append(nums[i] / nums[j])
                if nums[i] != 0:
                    operations.append(nums[j] / nums[i])
                
                for result in operations:
                    new_nums.append(result)
                    heuristic_val = min(heuristic_val, abs(target - result))
                    new_nums.pop()  # Remove the last added result to restore state
    
    return heuristic_val
Accuracy: 0.75 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average_value = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average_value) * len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    closest_value = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                closest_value = min(closest_value, abs(target - result))
            except ZeroDivisionError:
                continue
    
    heuristic_val = closest_value
    return heuristic_val
Accuracy: 0.75 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    closest_value = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                if abs(target - result) < abs(target - closest_value):
                    closest_value = result
            except ZeroDivisionError:
                continue
    
    heuristic_val = abs(target - closest_value)
    return heuristic_val
Accuracy: 0.75 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    min_operations = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                if result == target:
                    return 0
                elif result > 0:  # Only consider positive results
                    current_operations = len(ops) + 1  # Include the last number
                    min_operations = min(min_operations, current_operations)
            except ZeroDivisionError:
                continue
    
    heuristic_val = min_operations if min_operations != float('inf') else len(Numbers) + 1
    return heuristic_val
Accuracy: 0.75 
Function: 
from itertools import permutations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    operations = ['+', '-', '*', '/']
    min_diff = float('inf')
    
    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(Numbers) - 1):
            expr = str(nums[0])
            for i in range(len(ops)):
                expr += f" {ops[i]} {nums[i + 1]}"
            try:
                result = eval(expr)
                min_diff = min(min_diff, abs(target - result))
            except ZeroDivisionError:
                continue
    
    heuristic_val = min_diff
    return heuristic_val
Accuracy: 0.625 
Generation 3: 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = 0
    
    for number in Numbers:
        distance = abs(target - number)
        if distance > 0:
            heuristic_val += 1 / distance  # Higher weights for numbers closer to the target
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product_value = 1
    for num in Numbers:
        product_value *= num
    
    heuristic_val = abs(target - product_value) + len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    target = 24
    
    if target in Numbers:
        return 0
    
    heuristic_val = sum(abs(target - num) for num in Numbers)
    
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_possible_value = sum(Numbers)
    heuristic_val = max(0, (target - max_possible_value) / len(Numbers))
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_value = max(Numbers)
    min_value = min(Numbers)
    range_average = (max_value + min_value) / 2
    heuristic_val = abs(target - range_average) * len(Numbers)
    return heuristic_val
Accuracy: 0.25 
Function: 
from functools import reduce
import operator

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product_value = reduce(operator.mul, Numbers, 1)
    heuristic_val = abs(target - product_value) / (len(Numbers) if len(Numbers) > 0 else 1)
    
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = max(abs(target - num) for num in Numbers)
    
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    total_value = sum(Numbers)
    heuristic_val = abs(target - total_value) + len(Numbers) - 1
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_value = max(Numbers)
    min_value = min(Numbers)
    
    max_distance = abs(target - max_value)
    min_distance = abs(target - min_value)
    
    heuristic_val = max_distance + min_distance
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    current_sum = sum(Numbers)
    heuristic_val = abs(target - current_sum) + len(Numbers) - 1
    return heuristic_val
Accuracy: 0.25 
Function: 
from itertools import permutations, combinations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Calculate addition, subtraction, multiplication, and division
                operations = [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[j] - nums[i],
                    nums[i] * nums[j]
                ]
                
                if nums[j] != 0:
                    operations.append(nums[i] / nums[j])
                if nums[i] != 0:
                    operations.append(nums[j] / nums[i])
                
                for result in operations:
                    new_nums.append(result)
                    heuristic_val = min(heuristic_val, abs(target - result))
                    new_nums.pop()  # Remove the last added result to restore state
    
    return heuristic_val
Accuracy: 0.625 
Function: 
from itertools import permutations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        # Calculate potential maximum and minimum from current set of numbers
        max_possible = max(nums)
        min_possible = min(nums)
        
        # Evaluate all pairs
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Calculate addition and multiplication for potential maximum
                max_operations = [
                    max_possible * nums[i],
                    max_possible * nums[j],
                    max_possible + nums[i],
                    max_possible + nums[j]
                ]
                
                # Calculate subtraction and division for potential minimum
                min_operations = [
                    min_possible - nums[i],
                    min_possible - nums[j],
                    min_possible / (nums[i] if nums[i] != 0 else 1),
                    min_possible / (nums[j] if nums[j] != 0 else 1)
                ]
                
                for result in max_operations + min_operations:
                    heuristic_val = min(heuristic_val, abs(target - result))
    
    return heuristic_val
Accuracy: 0.375 
Function: 
from itertools import permutations

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Calculate addition, subtraction, multiplication, and division
                operations = [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[j] - nums[i],
                    nums[i] * nums[j]
                ]
                
                if nums[j] != 0:
                    operations.append(nums[i] / nums[j])
                if nums[i] != 0:
                    operations.append(nums[j] / nums[i])
                
                for result in operations:
                    new_nums.append(result)
                    heuristic_val = min(heuristic_val, abs(target - result) + 1)  # Adding 1 for the operation used
                    new_nums.pop()  # Remove the last added result to restore state
    
    return heuristic_val
Accuracy: 0.625 
Function: 
from itertools import permutations, combinations, product

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    heuristic_val = float('inf')
    
    for nums in permutations(Numbers):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                new_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]
                
                # Calculate addition, subtraction, multiplication, and division
                operations = [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[j] - nums[i],
                    nums[i] * nums[j]
                ]
                
                if nums[j] != 0:
                    operations.append(nums[i] / nums[j])
                if nums[i] != 0:
                    operations.append(nums[j] / nums[i])
                
                for result in operations:
                    new_nums.append(result)
                    heuristic_val = min(heuristic_val, abs(target - sum(new_nums)))
                    new_nums.pop()  # Remove the last added result to restore state
    
    return heuristic_val
Accuracy: 0.5 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    total_sum = sum(Numbers)
    heuristic_val = abs(target - total_sum) * len(Numbers)
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_combined_value = 0
    
    for i in range(len(Numbers)):
        for j in range(i + 1, len(Numbers)):
            combined_value = Numbers[i] * Numbers[j]
            if combined_value <= target:
                max_combined_value = max(max_combined_value, combined_value)
            combined_value = Numbers[i] + Numbers[j]
            if combined_value <= target:
                max_combined_value = max(max_combined_value, combined_value)
    
    heuristic_val = target - max_combined_value if max_combined_value < target else 0
    return heuristic_val
Accuracy: 0.5 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    current_sum = sum(Numbers)
    heuristic_val = abs(target - current_sum) + len(Numbers)
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_value = 1
    for num in Numbers:
        max_value *= num
    
    heuristic_val = abs(target - max_value)
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_possible_value = 1
    for number in Numbers:
        max_possible_value *= number
    
    heuristic_val = abs(target - max_possible_value) / len(Numbers)
    return heuristic_val
Accuracy: 0.25 
Generation 4: 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    min_combined_value = float('inf')
    
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                combined_value = Numbers[i] - Numbers[j]
                min_combined_value = min(min_combined_value, abs(combined_value))
                if Numbers[j] != 0:
                    combined_value = Numbers[i] / Numbers[j]
                    min_combined_value = min(min_combined_value, abs(combined_value))
    
    heuristic_val = min_combined_value if min_combined_value < target else target - min_combined_value
    return heuristic_val
Accuracy: 0.0 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for num in Numbers:
        product *= num
    
    # Determine how many operations (additions or multiplications) are needed to adjust
    heuristic_val = abs(target - product) + (len(Numbers) - 1)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for num in Numbers:
        product *= num
    
    heuristic_val = abs(target - product) + len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    sum_of_squares = sum(x ** 2 for x in Numbers)
    heuristic_val = abs((sum_of_squares / (target ** 2)) - 1) * 100  # Scale for better interpretability
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    sum_of_squares = sum(x ** 2 for x in Numbers)
    
    heuristic_val = abs(target - sum_of_squares) / target
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    current_product = 1
    for number in Numbers:
        current_product *= number
    
    heuristic_val = abs(target - current_product) + len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    sum_of_squares = sum(x**2 for x in Numbers)
    heuristic_val = abs(target - sum_of_squares) + len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for num in Numbers:
        product *= num
        
    max_additive_combination = sum(Numbers)
    
    heuristic_val = target - max(product, max_additive_combination)
    return heuristic_val if heuristic_val > 0 else 0
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for num in Numbers:
        product *= num
    
    heuristic_val = abs(target - product) + len(Numbers) - 1
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    sum_of_squares = sum(x**2 for x in Numbers)
    
    if sum_of_squares == 0:
        return float('inf')
    
    heuristic_val = abs(target - (sum_of_squares / len(Numbers)))
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    average = sum(Numbers) / len(Numbers)
    heuristic_val = abs(target - average) * len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for number in Numbers:
        product *= number
    
    heuristic_val = abs(target - product)
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    max_value = 1
    for num in Numbers:
        max_value *= num
    
    heuristic_val = abs(target - max_value) + len(Numbers)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    current_product = 1
    for num in Numbers:
        current_product *= num
    
    heuristic_val = abs(target - current_product) + len(Numbers) - 1
    return heuristic_val
Accuracy: 0.125 
Function: 
import math

def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for num in Numbers:
        product *= num
        
    heuristic_val = abs(target - product) + math.log(len(Numbers) + 1)
    return heuristic_val
Accuracy: 0.125 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    min_difference = float('inf')
    
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                combined_values = [
                    Numbers[i] + Numbers[j],
                    Numbers[i] - Numbers[j],
                    Numbers[i] * Numbers[j],
                    Numbers[i] / Numbers[j] if Numbers[j] != 0 else float('inf')
                ]
                for value in combined_values:
                    min_difference = min(min_difference, abs(target - value))
    
    heuristic_val = min_difference
    return heuristic_val
Accuracy: 0.5 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    product = 1
    for number in Numbers:
        product *= number
    
    heuristic_val = abs(target - product) / (len(Numbers) + 1)
    return heuristic_val
Accuracy: 0.25 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    min_difference = float('inf')
    
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                combined_values = [
                    Numbers[i] + Numbers[j],
                    Numbers[i] - Numbers[j],
                    Numbers[i] * Numbers[j],
                    Numbers[j] - Numbers[i],
                ]
                for value in combined_values:
                    if value > 0:  # Only consider positive results
                        min_difference = min(min_difference, abs(target - value))
    
    return min_difference
Accuracy: 0.75 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    closest_value = float('-inf')
    
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                combined_value_add = Numbers[i] + Numbers[j]
                combined_value_mul = Numbers[i] * Numbers[j]
                if combined_value_add <= target:
                    closest_value = max(closest_value, combined_value_add)
                if combined_value_mul <= target:
                    closest_value = max(closest_value, combined_value_mul)
    
    heuristic_val = target - closest_value if closest_value < target else 0
    return heuristic_val
Accuracy: 0.625 
Test the best heuristic in the last generation: 
Function: 
def calc_heuristic(Numbers):
    if 24 in Numbers:
        return 0
    
    target = 24
    min_difference = float('inf')
    
    for i in range(len(Numbers)):
        for j in range(len(Numbers)):
            if i != j:
                combined_values = [
                    Numbers[i] + Numbers[j],
                    Numbers[i] - Numbers[j],
                    Numbers[i] * Numbers[j],
                    Numbers[j] - Numbers[i],
                ]
                for value in combined_values:
                    if value > 0:  # Only consider positive results
                        min_difference = min(min_difference, abs(target - value))
    
    return min_difference
Accuracy: 0.41 
Test the best heuristic in all the generations: 
Function: 
def calc_heuristic(Numbers):
    from itertools import permutations, product

    if len(Numbers) == 1:
        return abs(Numbers[0] - 24)

    operations = ['+', '-', '*', '/']
    heuristic_val = float('inf')

    for nums in permutations(Numbers):
        for ops in product(operations, repeat=len(nums)-1):
            expression = str(nums[0])
            for i in range(len(ops)):
                expression += f" {ops[i]} {nums[i+1]}"
            try:
                result = eval(expression)
                heuristic_val = min(heuristic_val, abs(result - 24))
            except ZeroDivisionError:
                continue

    return heuristic_val
Accuracy: 0.54 
