Generation 0: 
Function: 
import numpy as np

# Heuristic Description: The heuristic calculates the sum of the minimum number of moves required to align each face to a uniform color by determining the most frequent color on each face and counting the number of non-matching squares.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_frequent_color_count = np.bincount(face).max()
        heuristic_val += 4 - most_frequent_color_count
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np
from collections import Counter

# Heuristic Description: The heuristic calculates the sum of the minimum number of moves required to make each face uniform by determining the most frequent color on each face and counting the squares that need changing.

def calc_heuristic(state):
    heuristic_val = 0
    # Iterate over each face of the cube
    for i in range(0, 24, 4):
        # Get the current face
        face = state[i:i+4]
        # Count the frequency of each color in the face
        color_count = Counter(face)
        # Find the most frequent color
        most_common_color_count = max(color_count.values())
        # Calculate the number of changes needed to make the face uniform
        heuristic_val += (4 - most_common_color_count)
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np
from collections import Counter

# Heuristic Description: Calculate the sum of the minimum number of moves needed to make each face have the same color by counting the most frequent color on each face and subtracting from 4.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face)
        most_common_color_count = color_count.most_common(1)[0][1]
        heuristic_val += (4 - most_common_color_count)
    return heuristic_val
Accuracy: 0.7333333333333333 
Function: 
import numpy as np
from collections import Counter

# Heuristic Description: The heuristic calculates the total number of squares on each face that do not match the majority color on that face, summed across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = Counter(face).most_common(1)[0][1]
        heuristic_val += (4 - most_common_color_count)
    return heuristic_val

Accuracy: 0.7333333333333333 
Generation 1: 
Function: 
import numpy as np
from collections import Counter

# Common idea: The provided heuristics focus on measuring how close each face is to being uniform in color by examining the most frequent color on each face.

# New heuristic description: Calculate the total number of different colors present on each face and sum these counts across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np
from collections import Counter

# Common idea: The heuristic evaluates the degree of uniformity of colors on each face of the cube.

# New heuristic description: The heuristic calculates the sum of unique colors present on each face across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np
from collections import Counter

# Common idea: The heuristic measures the degree of uniformity within each face of the cube.

# New heuristic description: The heuristic calculates the sum of the inverse of the count of the most common color for each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = Counter(face).most_common(1)[0][1]
        heuristic_val += 1 / most_common_color_count
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np
from collections import Counter

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face)
        common_colors = color_count.most_common(2)
        if len(common_colors) < 2:
            second_most_common_count = 0
        else:
            second_most_common_count = common_colors[1][1]
        heuristic_val += (4 - second_most_common_count)
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np
from collections import Counter

# Common Idea: All heuristics aim to measure how far each face is from being uniform in color, focusing on the frequency of colors on each face.

# New Heuristic Description: Calculate the maximum difference between the most and least frequent colors on each face, summed across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face).values()
        if len(color_count) > 1:
            max_diff = max(color_count) - min(color_count)
        else:
            max_diff = 0
        heuristic_val += max_diff
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

# Common Idea: The provided heuristics focus on assessing how far each face is from being uniform by evaluating the frequency of colors.

# New Heuristic Description: Calculate the sum of the distances of all pairs of squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        different_pairs = sum(1 for j in range(4) for k in range(j+1, 4) if face[j] != face[k])
        heuristic_val += different_pairs
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np
from collections import Counter

def calc_heuristic(state):
    color_count = Counter(state)
    most_common_color_count = color_count.most_common(1)[0][1]
    heuristic_val = 24 - most_common_color_count
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) > 1:  # If there is more than one unique color on the face
            heuristic_val += 1  # Add a fixed penalty for non-uniform face
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += (unique_colors - 1)
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        for j in range(0, 4, 2):
            if face[j] != most_common_color or face[j+1] != most_common_color:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Calculate adjacent pairs that need to be swapped
        pairs_to_swap = 0
        if face[0] != face[1]: pairs_to_swap += 1
        if face[1] != face[3]: pairs_to_swap += 1
        if face[3] != face[2]: pairs_to_swap += 1
        if face[2] != face[0]: pairs_to_swap += 1
        heuristic_val += pairs_to_swap // 2  # Each swap fixes two adjacent pairs
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

# Common idea: Evaluate the state of each face by quantifying the distance from a uniform color distribution.

# New heuristic description: Calculate the heuristic by summing the number of different colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face)
        heuristic_val += len(color_count) - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

# Common Idea: The existing heuristics focus on assessing the uniformity of colors on each face by considering the frequency of the most common color.

# New Heuristic: Calculate the total number of distinct colors present across all faces and subtract the number of faces with a single uniform color.

def calc_heuristic(state):
    unique_colors_count = len(set(state))
    uniform_faces_count = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            uniform_faces_count += 1
    heuristic_val = unique_colors_count - uniform_faces_count
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

# Common idea: Calculate the minimum number of moves needed to make each face have the same color by analyzing the color distribution on each face.

# New Heuristic Description: Calculate the sum of the squared differences of the color counts on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face)
        for count in color_count.values():
            heuristic_val += (4 - count) ** 2
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        distinct_colors = len(set(face))
        heuristic_val += (distinct_colors - 1)
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 2: 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = len(set(state)) - 1
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The provided heuristics focus on identifying and quantifying the deviation from a uniform color distribution on each face.

# New heuristic description: Calculate the heuristic by summing the maximum number of distinct colors present on any face of the cube.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val = max(heuristic_val, len(set(face)))
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np
from collections import Counter

# Common idea: Evaluate the degree of disorder by analyzing the distribution of colors on each face and how far they are from uniformity.

# New heuristic description: Calculate the heuristic by summing the differences between the most and least frequent colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face).values()
        heuristic_val += max(color_count) - min(color_count)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Count the number of squares not matching the majority color
        majority_color = max(set(face), key=face.count)
        mismatch_count = sum(1 for x in face if x != majority_color)
        heuristic_val += mismatch_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

# Common idea: Measure how far each face is from being uniform by counting discrepancies or variations.

# New heuristic description: Calculate the heuristic by summing the number of unique colors across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    unique_colors = set(state)
    heuristic_val = len(unique_colors) - 6  # Subtract 6 because a solved cube has 6 colors
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Calculate the number of squares that are not the majority color
        majority_color = max(set(face), key=face.count)
        mismatch_count = sum(1 for square in face if square != majority_color)
        heuristic_val += mismatch_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

# Common idea: Evaluate the degree of disorder on each face by analyzing the color distribution.

# New heuristic description: Calculate the heuristic by measuring the difference between the maximum and minimum color frequencies on each face, summed across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_count = Counter(face)
        max_freq = max(color_count.values())
        min_freq = min(color_count.values())
        heuristic_val += max_freq - min_freq
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

# Common idea: The heuristics assess the level of disorder on each face of the cube, using different metrics.

# New heuristic description: Calculate the heuristic by considering the sum of inversions within each face, where an inversion is a pair of adjacent squares that are not in the majority color.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        inversions = 0
        if face[0] != most_common_color and face[1] != most_common_color:
            inversions += 1
        if face[1] != most_common_color and face[3] != most_common_color:
            inversions += 1
        if face[3] != most_common_color and face[2] != most_common_color:
            inversions += 1
        if face[2] != most_common_color and face[0] != most_common_color:
            inversions += 1
        heuristic_val += inversions
    return heuristic_val

Accuracy: 0.5333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Calculate number of colors on the face
        unique_colors = len(set(face))
        # Subtract 1 because a uniform face should ideally have only 1 color
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Calculate the number of squares not matching the most common color
        most_common_color_count = max(face.count(face[j]) for j in range(4))
        # The heuristic value is the number of squares to change to reach uniformity
        heuristic_val += 4 - most_common_color_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: The heuristic evaluates how far each face is from being uniform by counting mismatches or required adjustments.

# New Heuristic Description: Calculate the number of squares on each face that do not match the most frequent color on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_frequent_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_frequent_color_count  # Count squares that don't match the most frequent color
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

# Common idea: Assess the degree of disorder by evaluating discrepancies from a uniform or desired state for each face.

# New heuristic description: Calculate the heuristic by summing the distances of each square's color index from the most common color index on its face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        for color in face:
            heuristic_val += abs(color - most_common_color)
    return heuristic_val

Accuracy: 0.6 
Function: 
import numpy as np

# Common Idea: The heuristics evaluate the uniformity of colors on each face by counting discrepancies from a desired state.

# New Heuristic Description: Calculate the number of unique colors on each face minus one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val += len(set(face)) - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) == 1:
            continue
        # Calculate the number of squares not matching the majority color
        majority_color = max(set(face), key=face.count)
        non_matching_squares = sum(1 for x in face if x != majority_color)
        heuristic_val += non_matching_squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: Measure the degree of uniformity on each face, aiming to minimize discrepancies among the squares.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        majority_color = max(set(face), key=face.count)
        mismatches = sum(1 for color in face if color != majority_color)
        heuristic_val += mismatches
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Count the occurrences of each color on the face
        color_count = np.bincount(face, minlength=6)
        # Calculate rotations needed by subtracting max occurrences from total squares
        rotations_needed = 4 - np.max(color_count)
        heuristic_val += rotations_needed
    return heuristic_val

Accuracy: 0.7333333333333333 
Generation 3: 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_frequent_color_count = max(face.count(color) for color in set(face))
        mismatch_pairs = (4 - most_frequent_color_count) * (3 - most_frequent_color_count) // 2
        heuristic_val += mismatch_pairs
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of disorder on each face by assessing discrepancies from a uniform state.

# New Heuristic Description: Calculate the heuristic by determining the minimum number of swaps needed to make each face uniform.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = list(set(face))
        min_swaps = float('inf')
        for color in unique_colors:
            swaps = 0
            for square in face:
                if square != color:
                    swaps += 1
            min_swaps = min(min_swaps, swaps // 2)
        heuristic_val += min_swaps
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        average_color = sum(face) / 4
        for color in face:
            heuristic_val += abs(color - average_color)
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np
from collections import Counter

# Common idea: Evaluate the degree of disorder by measuring the deviation from a uniform color distribution on each face.

# New heuristic description: Calculate the heuristic by counting the number of squares on each face that do not match the most common color on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        heuristic_val += sum(1 for color in face if color != most_common_color)
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        pairs = [(face[j], face[k]) for j in range(3) for k in range(j+1, 4)]
        heuristic_val += sum(1 for pair in pairs if pair[0] != pair[1]) // 2
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 because a uniform face should have 1 unique color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

# Common idea: Evaluate the degree of disorder by measuring the deviation from a uniform or desired state for each face.

# New heuristic description: Calculate the heuristic by summing the number of squares on each face that differ from the most common color on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        heuristic_val += sum(1 for color in face if color != most_common_color)
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of uniformity on each face by comparing squares to a target color or majority color, focusing on discrepancies.

# New Heuristic Description: Calculate the number of unique colors present on each face, aiming to minimize the diversity on a single face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 because a perfectly uniform face should have only 1 unique color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of disorder by assessing uniformity or similarities within each face of the cube.

# New Heuristic Description: Calculate the heuristic by summing the number of unique colors on each face and subtracting 1 (the ideal number of unique colors in a uniform face).

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 as a uniform face should have only 1 unique color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the deviation from a uniform face by considering mismatches or adjustments needed.

# New Heuristic Description: Calculate the number of pairs of adjacent squares on each face that do not match.

def calc_heuristic(state):
    heuristic_val = 0
    adjacency_indices = [(0, 1), (1, 3), (3, 2), (2, 0)]  # Pairs of adjacent indices on a face
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for idx1, idx2 in adjacency_indices:
            if face[idx1] != face[idx2]:
                heuristic_val += 1  # Count mismatched adjacent pairs
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of disorder or non-uniformity on each face of the cube.

# New Heuristic Description: Calculate the heuristic by summing the number of unique colors on each face minus one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if face[0] != face[1]:
            heuristic_val += 1
        if face[1] != face[3]:
            heuristic_val += 1
        if face[3] != face[2]:
            heuristic_val += 1
        if face[2] != face[0]:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 because a uniform face should have 1 unique color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np
from collections import Counter

# Common idea: Measure the degree of disorder on each face based on color frequency discrepancies.

# New heuristic description: Calculate the heuristic by summing the number of squares not matching the most common color on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = Counter(face).most_common(1)[0][0]
        for color in face:
            if color != most_common_color:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of uniformity or disorder on each face by comparing each square's color to the dominant or majority color on that face.

# New Heuristic Description: Calculate the heuristic by summing the number of unique colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 to measure non-uniformity
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 4: 
Function: 
import numpy as np

# Common Idea: The existing heuristics evaluate the level of disorder on each face by examining color uniformity and adjacency.

# New Heuristic Description: Calculate the heuristic by counting the number of pairs of opposite faces that contain entirely different sets of colors.

def calc_heuristic(state):
    heuristic_val = 0
    opposite_pairs = [(0, 15), (4, 19), (8, 23)]
    
    for first_idx, second_idx in opposite_pairs:
        first_face_colors = set(state[first_idx:first_idx+4])
        second_face_colors = set(state[second_idx:second_idx+4])
        
        if first_face_colors != second_face_colors:
            heuristic_val += 1

    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The provided heuristics evaluate the uniformity or disorder of each face by analyzing the arrangement of colors and comparing them against an ideal uniform state.

# New heuristic description: Calculate the heuristic by counting the number of faces where the most frequent color appears less than four times.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        max_color_count = max(face.count(color) for color in set(face))
        if max_color_count < 4:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of disorder by assessing deviations from uniformity on each face of the cube.

# New Heuristic Description: Calculate the heuristic by summing the absolute differences between the count of each color on a face and the count of the most frequent color on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face, minlength=6)
        max_count = np.max(color_counts)
        heuristic_val += sum(abs(count - max_count) for count in color_counts if count > 0)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    # Common Idea: Evaluate disorder by assessing deviations from uniformity on each face of the cube.
    
    # New Heuristic Description: Calculate the heuristic by summing the number of pairs of opposite faces 
    # that have different majority colors, emphasizing overall cube uniformity rather than individual face uniformity.
    
    heuristic_val = 0
    opposite_faces_indices = [(0, 12), (4, 16), (8, 20)]  # Pairs of opposite face indices
    for face1, face2 in opposite_faces_indices:
        majority_color_face1 = max(set(state[face1:face1+4]), key=state[face1:face1+4].count)
        majority_color_face2 = max(set(state[face2:face2+4]), key=state[face2:face2+4].count)
        if majority_color_face1 != majority_color_face2:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: Evaluate the degree of disorder on each face by assessing color discrepancies or non-uniformity.

# New Heuristic Description: Calculate the heuristic by summing the maximum deviation of each face from a single majority color.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        majority_count = max(face.count(face[j]) for j in range(4))
        heuristic_val += 4 - majority_count  # Subtract the count of the majority color from 4
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_common_color_count  # Subtract the count of the most common color from 4
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np
from collections import Counter

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = Counter(face)
        most_common_color_count = max(color_counts.values())
        moves_needed = 4 - most_common_color_count
        heuristic_val += moves_needed
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common Idea: Evaluate the disorder on each face by analyzing color patterns and differences from a uniform state.

# New Heuristic Description: Calculate the heuristic by summing the number of mismatched corners on each face, assuming an ideal corner has the same color on both adjacent squares.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Check each corner pair for mismatches
        if face[0] != face[1]:
            heuristic_val += 1
        if face[1] != face[3]:
            heuristic_val += 1
        if face[3] != face[2]:
            heuristic_val += 1
        if face[2] != face[0]:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color = max(set(face), key=face.count)
        diff_count = sum(1 for color in face if color != most_common_color)
        heuristic_val += diff_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += (4 - most_common_color_count)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_common_color_count  # Subtract the count of the most common color from 4
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face)
        if max(color_counts) < 3:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face and subtracting one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: Quantify the level of disorder by evaluating deviations from uniformity on each face of the cube.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing them.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# New Heuristic Implementation
def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 to account for the uniform face having only 1 color
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 5: 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face, minlength=6)
        squared_deviations = sum((count - 1) ** 2 for count in color_counts if count > 0)
        heuristic_val += squared_deviations
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The provided heuristics measure the degree of uniformity or disorder of each face by evaluating the diversity or deviation of colors on the face.

# New heuristic description: Calculate the heuristic by summing the inverses of the frequencies of the most common color on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_common_color_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of face pairs with different colors.

def calc_heuristic(state):
    heuristic_val = 0
    # Compare adjacent faces to see if they have any different colors
    for i in range(0, 24, 4):
        face1 = state[i:i+4]
        for j in range(i + 4, 24, 4):
            face2 = state[j:j+4]
            if len(set(face1) & set(face2)) == 0:  # If no common colors
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: Measure the disorder by examining the deviation from uniformity in color distribution on each face.

# New heuristic description: Calculate the heuristic by summing the absolute differences between the count of each color on a face and the ideal count (which is 4).

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = [face.count(color) for color in set(face)]
        heuristic_val += sum(abs(count - 4) for count in color_counts)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        max_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - max_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by summing the pairwise color differences on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_diffs = [abs(face[j] - face[k]) for j in range(4) for k in range(j+1, 4)]
        heuristic_val += sum(color_diffs)
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by summing the counts of the most frequent color on each face, subtracted from the total face elements.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_frequent_color_count = max(face.count(x) for x in set(face))
        heuristic_val += 4 - most_frequent_color_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of adjacent pairs with different colors on each face and summing them.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Count adjacent pairs with different colors
        adjacent_differences = sum(face[j] != face[j+1] for j in range(3))
        adjacent_differences += face[0] != face[3]  # Closing the loop for adjacency
        heuristic_val += adjacent_differences
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristic measures the number of squares on each face that do not match the most common color on that face.

# New heuristic description: Calculate the heuristic by summing the number of color changes between adjacent squares on all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val += sum(1 for j in range(3) if face[j] != face[j+1])
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        color_counts = {color: face.count(color) for color in unique_colors}
        for count in color_counts.values():
            diff = 4 - count
            heuristic_val += diff ** 2
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
        diff_count = sum(1 for a, b in adjacent_pairs if face[a] != face[b])
        heuristic_val += diff_count
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The existing heuristics assess the degree of disorder by measuring deviations from uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of adjacent pairs on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    adjacent_indices = [(0, 1), (1, 3), (3, 2), (2, 0)]  # indices of adjacent pairs on a 2x2 face
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for (a, b) in adjacent_indices:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += (unique_colors - 1) ** 2
    return heuristic_val

Accuracy: 0.8666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying deviations from uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by summing the number of misplaced squares on each face compared to the most frequent color on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_frequent_color_count = max(face.count(color) for color in set(face))
        misplaced_squares = 4 - most_frequent_color_count
        heuristic_val += misplaced_squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by measuring differences in color uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in adjacent_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 6: 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by quantifying non-uniformity or mismatches in color distribution on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of distinct colors present on each face and summing these counts for all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        heuristic_val += len(unique_colors)
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: Evaluate the state of the cube by assessing color uniformity and differences within and between each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors present on each face and summing the values for all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by comparing the current state to a potential restored state or a measure of uniformity.

# New heuristic description: Calculate the heuristic by counting the number of unique colors present on each face and summing these counts across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristic measures the degree of disorder by counting discrepancies or mismatches on cube faces.

# New heuristic description: Calculate the heuristic by summing the number of color changes across the edges between adjacent faces.

def calc_heuristic(state):
    heuristic_val = 0
    # Define the indices of edges between adjacent faces
    edges = [
        (0, 12), (1, 13), (2, 4), (3, 5),  # Upper to Down and Right
        (8, 16), (9, 17), (10, 6), (11, 7),  # Front to Left and Right
        (20, 18), (21, 19), (22, 14), (23, 15)  # Back to Left and Down
    ]
    # Calculate mismatches across the edges
    heuristic_val += sum(1 for a, b in edges if state[a] != state[b])
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        color_counts = {color: face.count(color) for color in unique_colors}
        max_count = max(color_counts.values())
        diff = 4 - max_count
        heuristic_val += diff * len(unique_colors)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        color_counts = {color: face.count(color) for color in unique_colors}
        average_count = 4 / len(unique_colors)
        for count in color_counts.values():
            diff = abs(count - average_count)
            heuristic_val += diff
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristic evaluates the degree of disorder by assessing mismatches in color patterns on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of distinct colors on each face and summing these counts.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val += len(set(face))
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        color_counts = {color: face.count(color) for color in unique_colors}
        max_count = max(color_counts.values())
        heuristic_val += (4 - max_count) * len(unique_colors)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics assess the degree of color uniformity on each face by evaluating discrepancies or differences in color distribution.

# New heuristic description: Calculate the heuristic by summing the number of pairs of opposite squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    opposite_pairs = [(0, 3), (1, 2)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in opposite_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors on each face, aiming for minimal diversity.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        max_color_count = max(face.count(color) for color in unique_colors)
        heuristic_val += (4 - max_color_count) * (len(unique_colors) - 1)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by measuring color uniformity and changes on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing the excess over one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristic measures the degree of disorder or mismatch within or across the faces of the cube.

# New heuristic description: Calculate the heuristic by summing the number of unique colors on each face minus one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val += len(set(face)) - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by assessing color differences and mismatches on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors_count = len(set(face))
        heuristic_val += unique_colors_count - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristic measures the discrepancies or mismatches within a face to determine how far it is from being uniform.

# New heuristic description: Calculate the heuristic by summing the number of squares on each face that do not match the first square on that face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        heuristic_val += sum(1 for j in range(4) if face[j] != face[0])
    return heuristic_val

Accuracy: 0.8 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder by assessing color uniformity and transitions on each face of the cube.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing the difference from the ideal state of 1 unique color per face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += (unique_colors - 1)
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 7: 
Function: 
import numpy as np

# Common idea: The heuristics evaluate the disorder of each face by measuring deviations from uniform color distribution.

# New heuristic description: Calculate the heuristic by summing the total number of colors that appear more than once on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face)
        heuristic_val += sum(count > 1 for count in color_counts if count > 0)
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate the disorder of each face by measuring differences in color distribution, aiming to quantify how far each face is from having uniform colors.

# New heuristic description: Calculate the heuristic by summing the total number of color mismatches across all adjacent edges between faces.

def calc_heuristic(state):
    heuristic_val = 0
    # Define pairs of adjacent edge squares between faces
    adjacent_pairs = [
        (0, 19), (1, 18), (2, 23), (3, 22),  # Upper-Left and Upper-Back edges
        (4, 11), (5, 10), (6, 15), (7, 14),  # Right-Front and Right-Down edges
        (8, 7),  (9, 6),  (10, 5), (11, 4),  # Front-Right and Front-Left edges
        (12, 17), (13, 16), (14, 7), (15, 6),  # Down-Left and Down-Front edges
        (16, 3),  (17, 2),  (18, 1), (19, 0),  # Left-Back and Left-Upper edges
        (20, 9),  (21, 8),  (22, 3), (23, 2)   # Back-Upper and Back-Left edges
    ]
    
    for a, b in adjacent_pairs:
        if state[a] != state[b]:
            heuristic_val += 1
            
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of mismatched squares compared to the most common color on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        mismatched_squares = 4 - most_common_color_count
        heuristic_val += mismatched_squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics assess the level of disorder on each face by evaluating the distribution and frequency of colors.

# New heuristic description: Calculate the heuristic by summing the number of triplet patterns (3 squares of the same color) on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for color in set(face):
            if face.count(color) == 3:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: Evaluate the degree of disorder on each face by analyzing color distribution and differences.

# New heuristic description: Calculate the heuristic by summing the squares of the counts of each unique color on each face, aiming for minimal variance.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = [face.count(color) for color in set(face)]
        heuristic_val += sum(count**2 for count in color_counts)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common Idea: The heuristic estimates how far each face is from being uniform by considering the diversity of colors and how many moves it would take to make all squares on a face the same.

# New Heuristic: Calculate the heuristic based on the number of unique colors per face and the minimum moves to convert the majority color into a uniform face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        max_color_count = max(face.count(color) for color in unique_colors)
        heuristic_val += (4 - max_color_count)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristic is designed to quantify the deviation of each face from being uniform in color, factoring in the number of unique colors and how many tiles are not part of the majority color.

# New heuristic description: Calculate the total number of tiles on each face that are not of the majority color, and sum these counts across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        max_color_count = max(face.count(color) for color in unique_colors)
        heuristic_val += (4 - max_color_count)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate the deviation from uniformity on each face by measuring color differences and discrepancies.

# New heuristic description: Calculate the heuristic by summing the total number of adjacent pairs on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in adjacent_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of pairs of adjacent squares with different colors across all faces.

def calc_heuristic(state):
    heuristic_val = 0
    adjacency_pairs = [
        (0, 1), (1, 3), (3, 2), (2, 0),  # Upper face
        (4, 5), (5, 7), (7, 6), (6, 4),  # Right face
        (8, 9), (9, 11), (11, 10), (10, 8),  # Front face
        (12, 13), (13, 15), (15, 14), (14, 12),  # Down face
        (16, 17), (17, 19), (19, 18), (18, 16),  # Left face
        (20, 21), (21, 23), (23, 22), (22, 20)   # Back face
    ]
    
    for a, b in adjacency_pairs:
        if state[a] != state[b]:
            heuristic_val += 1
    
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of color transitions between adjacent squares on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        transitions = sum(1 for j in range(3) if face[j] != face[j+1])
        transitions += face[0] != face[3]  # Considering wrap-around transition
        heuristic_val += transitions
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of adjacent pairs of different colors on each face, aiming for minimal adjacent differences.

def calc_heuristic(state):
    heuristic_val = 0
    face_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in face_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics assess the degree of disorder on each face by evaluating color discrepancies and aiming for uniformity.

# New heuristic description: Calculate the heuristic by summing the number of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in adjacent_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate the degree of disorder by assessing color differences and uniformity on each face of the cube.

# New heuristic description: Calculate the heuristic by summing the total number of color changes between adjacent squares on the cube.

def calc_heuristic(state):
    heuristic_val = 0
    face_indices = [
        (0, 1), (1, 2), (2, 3), (3, 0),  # Upper face
        (4, 5), (5, 6), (6, 7), (7, 4),  # Right face
        (8, 9), (9, 10), (10, 11), (11, 8),  # Front face
        (12, 13), (13, 14), (14, 15), (15, 12),  # Down face
        (16, 17), (17, 18), (18, 19), (19, 16),  # Left face
        (20, 21), (21, 22), (22, 23), (23, 20)  # Back face
    ]
    for (a, b) in face_indices:
        if state[a] != state[b]:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: The heuristics measure the degree of disorder on each face by assessing color differences and aiming to reduce them.

# New heuristic description: Calculate the heuristic by summing the number of adjacent pairs of squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for a, b in adjacent_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = set(face)
        max_color_count = max(face.count(color) for color in unique_colors)
        other_colors_count = sum(face.count(color) for color in unique_colors if face.count(color) != max_color_count)
        heuristic_val += other_colors_count
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristic evaluates the uniformity of colors on each face by counting the number of color mismatches.

# New heuristic description: Calculate a heuristic value based on the sum of the number of unique colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 8: 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing these counts.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the square of the number of unique colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors ** 2
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The provided heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing these counts.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face and summing these counts.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors
    return heuristic_val

Accuracy: 0.0 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 because a uniform face has 1 unique color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of different colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of distinct colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        distinct_colors = len(set(face))
        heuristic_val += distinct_colors - 1  # Subtract 1 to make heuristic 0 when all squares on a face are the same color
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face, subtracting one.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of distinct colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        distinct_colors = len(set(face))
        heuristic_val += distinct_colors - 1  # Subtracting 1 because a uniform face (1 color) should contribute 0
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by counting the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtract 1 to give zero score for a uniform face
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += unique_colors - 1  # Subtracting 1 because a perfectly uniform face will contribute 0
    return heuristic_val

Accuracy: 0.9333333333333333 
Generation 9: 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of squares that are different from the most common color on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_common_color_count  # Subtract most common color count from total squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of misplaced squares compared to a face's most common color.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        misplaced_squares = 4 - most_common_color_count
        heuristic_val += misplaced_squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of non-majority colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        majority_color_count = max(face.count(face[0]), face.count(face[1]), face.count(face[2]), face.count(face[3]))
        non_majority_colors = 4 - majority_color_count
        heuristic_val += non_majority_colors
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    face_indices = [(0, 1), (1, 2), (2, 3), (3, 0)]  # Adjacent pairs on a face
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for (a, b) in face_indices:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of squares that do not match the most common color on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(color) for color in set(face))
        heuristic_val += 4 - most_common_color_count  # Subtracting from 4 to count non-matching squares
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of pairs of adjacent squares on a face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Check pairs (0,1), (1,2), (2,3), and (3,0) for color differences
        if face[0] != face[1]:
            heuristic_val += 1
        if face[1] != face[2]:
            heuristic_val += 1
        if face[2] != face[3]:
            heuristic_val += 1
        if face[3] != face[0]:
            heuristic_val += 1
    return heuristic_val

Accuracy: 0.6666666666666666 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring the level of uniformity or differences in color on each face.

# New heuristic description: Calculate the heuristic by summing the maximum number of a single color on each face subtracted from 4.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        max_color_count = max([face.count(color) for color in set(face)])
        heuristic_val += 4 - max_color_count  # The more uniform, the smaller the contribution
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of non-dominant colors on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face)
        dominant_color_count = np.max(color_counts)
        non_dominant_count = 4 - dominant_color_count
        heuristic_val += non_dominant_count
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the squared number of unique colors present on each face.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        unique_colors = len(set(face))
        heuristic_val += (unique_colors - 1) ** 2  # Squaring the difference to emphasize larger variations
    return heuristic_val

Accuracy: 0.8666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the maximum count of the most frequent color on each face subtracted from 4.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        color_counts = np.bincount(face)
        max_color_count = np.max(color_counts)
        heuristic_val += 4 - max_color_count  # Subtracting from 4 because a perfectly uniform face will contribute 0
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the absolute difference from 2 for each face's most common color count.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(face.count(c) for c in set(face))
        heuristic_val += abs(2 - most_common_color_count)
    return heuristic_val

Accuracy: 0.06666666666666667 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Compare adjacent squares in a 2x2 face grid: (0 with 1), (1 with 3), (3 with 2), (2 with 0)
        if face[0] != face[1]: heuristic_val += 1
        if face[1] != face[3]: heuristic_val += 1
        if face[3] != face[2]: heuristic_val += 1
        if face[2] != face[0]: heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the maximum number of repeated colors on each face subtracted from 4.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        most_common_color_count = max(np.bincount(face))
        heuristic_val += 4 - most_common_color_count
    return heuristic_val

Accuracy: 0.7333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Count the number of adjacent pairs with different colors
        heuristic_val += (face[0] != face[1]) + (face[1] != face[3]) + (face[3] != face[2]) + (face[2] != face[0])
    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of face transitions where adjacent squares have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    # Define adjacent pairs for each face
    face_pairs = [
        (0, 1), (1, 3), (3, 2), (2, 0),  # Upper face
        (4, 5), (5, 7), (7, 6), (6, 4),  # Right face
        (8, 9), (9, 11), (11, 10), (10, 8),  # Front face
        (12, 13), (13, 15), (15, 14), (14, 12),  # Down face
        (16, 17), (17, 19), (19, 18), (18, 16),  # Left face
        (20, 21), (21, 23), (23, 22), (22, 20)   # Back face
    ]
    
    for i in range(0, 24, 4):
        face = state[i:i+4]
        for pair in face_pairs[i // 4 * 4:i // 4 * 4 + 4]:  # Get the pairs for the current face
            if face[pair[0] - i] != face[pair[1] - i]:  # Compare adjacent squares
                heuristic_val += 1

    return heuristic_val

Accuracy: 0.9333333333333333 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Check adjacent pairs: (0,1), (1,3), (3,2), (2,0)
        adjacent_pairs = [(0, 1), (1, 3), (3, 2), (2, 0)]
        for a, b in adjacent_pairs:
            if face[a] != face[b]:
                heuristic_val += 1
    return heuristic_val

Accuracy: 0.9333333333333333 
Test the best heuristic in the last generation: 
Function: 
import numpy as np

# Common idea: The heuristics evaluate disorder by measuring color differences and uniformity on each face.

# New heuristic description: Calculate the heuristic by summing the total number of pairs of adjacent squares on each face that have different colors.

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        # Compare adjacent squares in a 2x2 face grid: (0 with 1), (1 with 3), (3 with 2), (2 with 0)
        if face[0] != face[1]: heuristic_val += 1
        if face[1] != face[3]: heuristic_val += 1
        if face[3] != face[2]: heuristic_val += 1
        if face[2] != face[0]: heuristic_val += 1
    return heuristic_val

Accuracy: 0.9180327868852459 
Test the best heuristic in all the generations: 
Function: 
import numpy as np

def calc_heuristic(state):
    heuristic_val = 0
    for i in range(0, 24, 4):
        face = state[i:i+4]
        if len(set(face)) > 1:  # If there is more than one unique color on the face
            heuristic_val += 1  # Add a fixed penalty for non-uniform face
    return heuristic_val

Accuracy: 0.8306010928961749 
